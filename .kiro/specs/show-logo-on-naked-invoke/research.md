# 調査・設計判断ログ

## 概要
- **機能**: `show-logo-on-naked-invoke`
- **ディスカバリー範囲**: シンプルな機能追加
- **主要な発見**:
  - `typer`のコールバック機能を利用して、サブコマンドなしの呼び出しを検知できる。
  - `rich.console`がすでに利用されており、ロゴ表示に適している。
  - ロゴは`modaryn/outputs/`配下に新しいモジュールとして分離するのが、既存の構造と一貫性がある。

## 調査ログ

### `typer`でのデフォルトコマンドの実装方法
- **コンテキスト**: 引数なしで`modaryn`が呼ばれた際に特定の動作（ロゴ表示）をさせる方法を特定する必要があった。
- **調査ソース**: `typer`公式ドキュメント、既存の`modaryn/cli.py`のコード。
- **発見**:
  - `typer.Typer`のインスタンス化時に`invoke_without_command=True`を設定する。
  - `@app.callback()`デコレータを持つ関数に`ctx: typer.Context`引数を追加する。
  - `ctx.invoked_subcommand`が`None`であるかどうかをチェックすることで、サブコマンドなしの呼び出しを判定できる。
- **影響**: このアプローチにより、既存の`score`コマンドの動作に影響を与えることなく、新しいデフォルトの振る舞いを安全に追加できる。

## 設計判断

### 判断: ロゴの保存場所
- **コンテキスト**: ASCIIロゴの文字列をどこに保存するかを決定する必要があった。
- **検討した代替案**:
  1. `cli.py`内に直接ハードコーディングする: 実装は最も簡単だが、`cli.py`の関心事（CLIのオーケストレーション）と表示用の定数を混在させてしまう。
  2. 別の`.txt`ファイルに保存し、実行時に読み込む: ロゴの変更は容易になるが、パッケージングの際にファイルを含める必要があり、わずかに複雑性が増す。
  3. 新しいPythonモジュールに定数として保存する: 関心の分離を維持しつつ、パッケージングも容易。
- **選択したアプローチ**: `modaryn/outputs/logo.py`という新しいファイルを作成し、そこにロゴ文字列を定数として格納する。
- **論拠**: `modaryn/outputs/`ディレクトリは既に出力（表示）関連のモジュール（`terminal.py`, `html.py`など）を管理しており、ここにロゴ表示のロジックを追加することは、プロジェクトの既存の構造的パターンに合致する。これにより、`cli.py`はオーケストレーションに集中できる。
- **トレードオフ**: `cli.py`にハードコーディングするよりはわずかにファイルが多くなるが、コードの可読性と保守性が向上するメリットの方が大きい。

